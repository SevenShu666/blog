(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{451:function(v,_,t){"use strict";t.r(_);var a=t(10),r=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"http知识体系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http知识体系"}},[v._v("#")]),v._v(" HTTP知识体系")]),v._v(" "),_("p",[v._v("超文本传输协议，用于两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。")]),v._v(" "),_("h2",{attrs:{id:"一、http的特点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、http的特点和缺点"}},[v._v("#")]),v._v(" 一、HTTP的特点和缺点")]),v._v(" "),_("h3",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ul",[_("li",[v._v("无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息")]),v._v(" "),_("li",[v._v("灵活：通过http协议中"),_("code",[v._v("content-type")]),v._v("标记，可以传输任意数据类型的数据对象")]),v._v(" "),_("li",[v._v("请求-应答模式：一方发出消息，另一方接收消息做出应答")])]),v._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("无状态：请求不会记录任何连接信息，因此如果后续的请求需要用到前面的信息，它就必须重新传输，这就可能导致传输的数据量增大")]),v._v(" "),_("li",[v._v("明文传输：报文（header部分）使用的是明文，直接将信息暴露给外界，给攻击者带来便利")]),v._v(" "),_("li",[v._v("队头阻塞：当http开始长连接时，共用一个tcp连接，当某个请求耗时过长时，就会阻塞其他请求，造成队头阻塞")])]),v._v(" "),_("h2",{attrs:{id:"二、http报文的组成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、http报文的组成"}},[v._v("#")]),v._v(" 二、HTTP报文的组成")]),v._v(" "),_("h3",{attrs:{id:"http报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http报文"}},[v._v("#")]),v._v(" HTTP报文")]),v._v(" "),_("p",[v._v("请求报文和响应报文")]),v._v(" "),_("p",[_("strong",[v._v("请求报文")]),v._v("：请求行、请求头、空行、请求体")]),v._v(" "),_("ul",[_("li",[v._v("请求行：包含http方法，请求地址，http协议以及版本")]),v._v(" "),_("li",[v._v("请求头：一些key：value，告诉服务端需要哪些资源以及类型")]),v._v(" "),_("li",[v._v("空行：用于区分头部和实体，告诉服务端怎么解析")]),v._v(" "),_("li",[v._v("请求体：请求的参数")])]),v._v(" "),_("p",[_("strong",[v._v("响应报文")]),v._v("：状态行、响应头、空行、响应体")]),v._v(" "),_("ul",[_("li",[v._v("状态行：包含http协议以及版本，数字状态码，状态码英文名称")]),v._v(" "),_("li",[v._v("响应头：一些key：value，告诉服务端需要哪些资源以及类型")]),v._v(" "),_("li",[v._v("空行：用于区分头部和实体，告诉服务端怎么解析")]),v._v(" "),_("li",[v._v("响应体：服务端返回的数据")])]),v._v(" "),_("h3",{attrs:{id:"三、http的请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、http的请求方法"}},[v._v("#")]),v._v(" 三、HTTP的请求方法")]),v._v(" "),_("h3",{attrs:{id:"http1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[v._v("#")]),v._v(" HTTP1.0")]),v._v(" "),_("p",[_("code",[v._v("GET")]),v._v("、"),_("code",[v._v("POST")]),v._v("、"),_("code",[v._v("HEAD")])]),v._v(" "),_("h3",{attrs:{id:"http1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[v._v("#")]),v._v(" HTTP1.1")]),v._v(" "),_("p",[_("code",[v._v("PUT")]),v._v("、"),_("code",[v._v("PATCH")]),v._v("、"),_("code",[v._v("DELETE")]),v._v("、"),_("code",[v._v("OPTIONS")]),v._v("、"),_("code",[v._v("POST")]),v._v("、"),_("code",[v._v("CONNECT")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("方法")]),v._v(" "),_("th",[v._v("描述")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("GET")]),v._v(" "),_("td",[v._v("获取资源")])]),v._v(" "),_("tr",[_("td",[v._v("POST")]),v._v(" "),_("td",[v._v("传输资源，通常会造成服务器资源的修改")])]),v._v(" "),_("tr",[_("td",[v._v("HEAD")]),v._v(" "),_("td",[v._v("获得报文首部")])]),v._v(" "),_("tr",[_("td",[v._v("PUT")]),v._v(" "),_("td",[v._v("更新资源")])]),v._v(" "),_("tr",[_("td",[v._v("PATCH")]),v._v(" "),_("td",[v._v("对PUT的补充，对已知资源部分更新")])]),v._v(" "),_("tr",[_("td",[v._v("DELETE")]),v._v(" "),_("td",[v._v("删除资源")])]),v._v(" "),_("tr",[_("td",[v._v("OPTIONS")]),v._v(" "),_("td",[v._v("列出请求资源支持的请求方法，用来跨域请求")])]),v._v(" "),_("tr",[_("td",[v._v("TRACE")]),v._v(" "),_("td",[v._v("追踪请求/响应路径，用于测试或诊断")])]),v._v(" "),_("tr",[_("td",[v._v("CONNECT")]),v._v(" "),_("td",[v._v("将连接改为管道方式用于代理服务器(隧道代理)")])])])]),v._v(" "),_("h3",{attrs:{id:"get和post的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post的区别"}},[v._v("#")]),v._v(" GET和POST的区别")]),v._v(" "),_("ul",[_("li",[v._v("GET请求参数会被浏览器历史记录保存，而POST请求参数不会被保留")]),v._v(" "),_("li",[v._v("GET请求参数是拼接在url上，POST请求的参数在请求体里")]),v._v(" "),_("li",[v._v("浏览器对url的长度有限制，因此GET请求的参数大小会被限制，POST请求参数基本上没有限制")]),v._v(" "),_("li",[v._v("GET请求的参数直接暴露在URL上，相对POST来说更不安全")])]),v._v(" "),_("h2",{attrs:{id:"四、常见http状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、常见http状态码"}},[v._v("#")]),v._v(" 四、常见HTTP状态码")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("状态码")]),v._v(" "),_("th",[v._v("描述")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("200")]),v._v(" "),_("td",[v._v("请求成功")])]),v._v(" "),_("tr",[_("td",[v._v("206")]),v._v(" "),_("td",[v._v("已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时")])]),v._v(" "),_("tr",[_("td",[v._v("301")]),v._v(" "),_("td",[v._v("永久重定向")])]),v._v(" "),_("tr",[_("td",[v._v("302")]),v._v(" "),_("td",[v._v("临时重定向")])]),v._v(" "),_("tr",[_("td",[v._v("304")]),v._v(" "),_("td",[v._v("请求资源未修改，可以使用缓存的资源，不用在服务器取")])]),v._v(" "),_("tr",[_("td",[v._v("400")]),v._v(" "),_("td",[v._v("请求有语法错误")])]),v._v(" "),_("tr",[_("td",[v._v("401")]),v._v(" "),_("td",[v._v("没有权限访问")])]),v._v(" "),_("tr",[_("td",[v._v("403")]),v._v(" "),_("td",[v._v("服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时")])]),v._v(" "),_("tr",[_("td",[v._v("404")]),v._v(" "),_("td",[v._v("请求资源不存在")])]),v._v(" "),_("tr",[_("td",[v._v("500")]),v._v(" "),_("td",[v._v("服务器内部错误，无法完成请求")])]),v._v(" "),_("tr",[_("td",[v._v("503")]),v._v(" "),_("td",[v._v("请求未完成，因服务器过载、宕机或维护等")])])])]),v._v(" "),_("h2",{attrs:{id:"五、长连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、长连接"}},[v._v("#")]),v._v(" 五、长连接")]),v._v(" "),_("ul",[_("li",[v._v("HTTP1.0协议采用的是“请求-应答”模式，每个请求/应答客户端和服务端都会新建一个请求，请求完成后立即断开")]),v._v(" "),_("li",[v._v("HTTP1.1协议支持长连接模式，在请求头添加"),_("code",[v._v("Connection:Keep-Alive")]),v._v("，开启长连接模式，建立一个TCP连接后客户端和服务端的连接就持续有效")])]),v._v(" "),_("h3",{attrs:{id:"长连接的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#长连接的优缺点"}},[v._v("#")]),v._v(" 长连接的优缺点")]),v._v(" "),_("h4",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("减少CPU及内存的使用，因为不需要经常建立和关闭连接")]),v._v(" "),_("li",[v._v("支持管道化的请求和响应模式")]),v._v(" "),_("li",[v._v("减少了网络阻塞，因为减少了TCP请求")]),v._v(" "),_("li",[v._v("减少了后续请求的响应时间，因为不用通过三次握手建立连接和四次挥手断开连接")]),v._v(" "),_("li",[v._v("发生错误的时候，也可以在不关闭连接的时候进行错误提示")])]),v._v(" "),_("h4",{attrs:{id:"缺点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("长时间保持连接会导致服务器资源浪费")]),v._v(" "),_("li",[v._v("可能造成队头阻塞")])]),v._v(" "),_("h3",{attrs:{id:"长连接关闭设置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#长连接关闭设置"}},[v._v("#")]),v._v(" 长连接关闭设置")]),v._v(" "),_("ul",[_("li",[v._v("客户端配置：请求头声明"),_("code",[v._v("Connection:close")]),v._v("，本次通信完成之后关闭连接")]),v._v(" "),_("li",[v._v("服务端配置："),_("code",[v._v("keepalive_timeout")]),v._v("设置长连接超时时间，"),_("code",[v._v("keepalive_requests")]),v._v("设置长连接请求次数上限")])]),v._v(" "),_("h2",{attrs:{id:"六、管道化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、管道化"}},[v._v("#")]),v._v(" 六、管道化")]),v._v(" "),_("ul",[_("li",[v._v("使用长连接时，通信是：请求1->响应1->请求2->响应2->请求3->响应3")]),v._v(" "),_("li",[v._v("管道化方式：请求1->请求2->请求3->响应1->响应2->响应3")])]),v._v(" "),_("p",[v._v("管道化：在同一个TCP连接里发一个请求不必等其回来就可以继续发请求出去，这可以减少整体的响应时间，但服务器还是会按照请求的发起顺序进行响应，如果前面的请求响应很慢，就会造成队头阻塞问题")]),v._v(" "),_("h3",{attrs:{id:"特点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点-2"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ul",[_("li",[v._v("管道化机制通过持久化连接完成，在HTTP1.1才支持")]),v._v(" "),_("li",[v._v("只有GET请求和HEAD请求支持，POST请求有限制")]),v._v(" "),_("li",[v._v("管道化不会影响响应的顺序")])]),v._v(" "),_("h2",{attrs:{id:"七、队头阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七、队头阻塞"}},[v._v("#")]),v._v(" 七、队头阻塞")]),v._v(" "),_("p",[v._v("长连接开启管道化的时候，当前面的请求响应过慢时，就会阻塞后面的请求")]),v._v(" "),_("ul",[_("li",[v._v("并发连接：一个域名可以分配多个长连接，相当于增加任务队列，现在的浏览器标准一个域名并发连接可以有6~8个")]),v._v(" "),_("li",[v._v("域名分片：多准备几个二级域名")])]),v._v(" "),_("h2",{attrs:{id:"八、http代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#八、http代理"}},[v._v("#")]),v._v(" 八、HTTP代理")]),v._v(" "),_("p",[v._v("常见代理有两种：普通代理（中间人代理）、隧道代理")]),v._v(" "),_("h3",{attrs:{id:"普通代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#普通代理"}},[v._v("#")]),v._v(" 普通代理")]),v._v(" "),_("p",[v._v("代理服务器相当于一个中间人为客户端和服务端两边传递东西")]),v._v(" "),_("p",[v._v("用处：过滤、缓存、负载均衡")]),v._v(" "),_("h3",{attrs:{id:"隧道代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隧道代理"}},[v._v("#")]),v._v(" 隧道代理")]),v._v(" "),_("p",[v._v("客户端通过connect方法请求隧道代理创建一个可以到任意目标服务器和端口的TCP连接，创建成功之后隧道代理只做请求和响应的转发，中间它不会做任何处理。")]),v._v(" "),_("p",[v._v("HTTPS服务需要网站有证书，而代理服务器是没有的，所以浏览器和代理服务器之间建立不了TLS，所以隧道代理会把浏览器的数据原样透传，这样就可以实现通过中间代理和服务端进行TLS握手，然后进行加密传输")]),v._v(" "),_("h3",{attrs:{id:"代理服务器的好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器的好处"}},[v._v("#")]),v._v(" 代理服务器的好处")]),v._v(" "),_("ul",[_("li",[v._v("突破访问限制：使用国外的代理服务器，就可以访问国外的网站")]),v._v(" "),_("li",[v._v("安全性更高：通过这种方式可以隐藏自己的IP")]),v._v(" "),_("li",[v._v("负载均衡：代理服务器通过特定的算法（随机算法、轮询、一致性hash）把请求分发给不同的源服务器，让各个源服务器负载尽量均衡")]),v._v(" "),_("li",[v._v("缓存代理：将内容缓存到代理服务器")])]),v._v(" "),_("h2",{attrs:{id:"九、正向代理和反向代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#九、正向代理和反向代理"}},[v._v("#")]),v._v(" 九、正向代理和反向代理")]),v._v(" "),_("h3",{attrs:{id:"正向代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#正向代理"}},[v._v("#")]),v._v(" 正向代理")]),v._v(" "),_("p",[v._v("工作在客户端的代理为正向代理。使用正向代理的时候，需要在客户端配置需要使用的代理服务器，正向代理对服务端透明。比如抓包工具Fiddler、Charles")]),v._v(" "),_("p",[v._v("作用：缓存、访问无法访问的网站")]),v._v(" "),_("h3",{attrs:{id:"反向代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反向代理"}},[v._v("#")]),v._v(" 反向代理")]),v._v(" "),_("p",[v._v("工作在服务端的代理为反向代理。反向代理对客户端透明。如Nginx")]),v._v(" "),_("p",[v._v("作用：负载均衡、服务端缓存、日志")]),v._v(" "),_("h2",{attrs:{id:"十、http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十、http缓存"}},[v._v("#")]),v._v(" 十、HTTP缓存")]),v._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),_("ol",[_("li",[v._v("HTTP1.0使用的是Expires")]),v._v(" "),_("li",[v._v("HTTP1.1使用的是Cache-Control")]),v._v(" "),_("li",[v._v("Cache-Control的优先级更高")])]),v._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[v._v("#")]),v._v(" Expires")]),v._v(" "),_("p",[v._v("表示的是"),_("strong",[v._v("过期时间")]),v._v("，时间是相对于服务器的时间，从响应头返回，在这个过期时间之前都可以从缓存中获取数据，无需再次请求。")]),v._v(" "),_("p",[_("strong",[v._v("问题")]),v._v("：服务器的时间可能和浏览器的时间不一样")]),v._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[v._v("#")]),v._v(" Cache-Control")]),v._v(" "),_("p",[v._v("表示的是"),_("strong",[v._v("过期时长")]),v._v("，对应的字段是max-age："),_("code",[v._v("Cache-Control: max-age=6000")])]),v._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),_("ol",[_("li",[v._v("HTTP1.0使用的是Last-Modified")]),v._v(" "),_("li",[v._v("HTTP1.1使用的是ETag")]),v._v(" "),_("li",[v._v("ETag的优先级更高")])]),v._v(" "),_("h4",{attrs:{id:"last-modified"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[v._v("#")]),v._v(" Last-Modified")]),v._v(" "),_("p",[v._v("表示的是"),_("strong",[v._v("最后修改时间")])]),v._v(" "),_("ol",[_("li",[v._v("浏览器第一次请求资源后服务器会在响应头加上这个字段")]),v._v(" "),_("li",[v._v("浏览器再次请求时，会将这个字段给到if-modified-since")]),v._v(" "),_("li",[v._v("服务器拿到字段之后，会去跟资源的最后修改时间进行比较")]),v._v(" "),_("li",[v._v("如果值小于最后修改时间，返回新的资源，并更新Last-Modified的值")]),v._v(" "),_("li",[v._v("否则返回304，浏览器取用缓存的资源")])]),v._v(" "),_("p",[_("strong",[v._v("问题")]),v._v("：Last-Modified能够感应级别是秒级，如果资源在1秒内做了更改，那么Last-Modified没有变化")]),v._v(" "),_("h4",{attrs:{id:"etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[v._v("#")]),v._v(" ETag")]),v._v(" "),_("p",[v._v("表示的是"),_("strong",[v._v("对资源生成的唯一标识")])]),v._v(" "),_("ol",[_("li",[v._v("浏览器第一次请求资源后服务器会在响应头加上这个字段")]),v._v(" "),_("li",[v._v("浏览器再次请求时，会将这个字段给到if-None-Match")]),v._v(" "),_("li",[v._v("服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对")]),v._v(" "),_("li",[v._v("如果两者不一样，返回新的资源，并更新ETag的值")]),v._v(" "),_("li",[v._v("否则返回304，浏览器取用缓存的资源")])]),v._v(" "),_("h2",{attrs:{id:"十一、https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十一、https"}},[v._v("#")]),v._v(" 十一、HTTPS")]),v._v(" "),_("p",[v._v("HTTPS是超文本传输安全协议，即HTTP+SSL/TLS，多了一个安全层")]),v._v(" "),_("h2",{attrs:{id:"十二、http-和-https-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十二、http-和-https-的区别"}},[v._v("#")]),v._v(" 十二、HTTP 和 HTTPS 的区别")]),v._v(" "),_("ul",[_("li",[v._v("HTTP是"),_("code",[v._v("明文传输")]),v._v("，不安全的，HTTPS是"),_("code",[v._v("加密传输")]),v._v("，安全的多")]),v._v(" "),_("li",[v._v("HTTP标准端口是"),_("code",[v._v("80")]),v._v("，HTTPS标准端口是"),_("code",[v._v("443")])]),v._v(" "),_("li",[v._v("HTTP不用认证证书"),_("code",[v._v("免费")]),v._v("，HTTPS需要认证证书"),_("code",[v._v("要钱")])]),v._v(" "),_("li",[_("code",[v._v("连接方式不同")]),v._v("，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次")]),v._v(" "),_("li",[v._v("HTTP是"),_("code",[v._v("无状态")]),v._v("的，HTTPS是"),_("code",[v._v("有状态")]),v._v("的")])]),v._v(" "),_("h2",{attrs:{id:"十三、http2-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十三、http2-0"}},[v._v("#")]),v._v(" 十三、HTTP2.0")]),v._v(" "),_("ol",[_("li",[v._v("使用新的二进制协议，不再是纯文本，缩小了请求体积")]),v._v(" "),_("li",[v._v("多路复用，同域名下的所有通信都在但单个连接下完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，一个消息包含一个或多个帧，多个帧可以乱序发送，后面通过帧首部的流标识进行组装("),_("strong",[v._v("解决应用层的队头阻塞问题")]),v._v(")")]),v._v(" "),_("li",[v._v("允许服务端主动推送数据到客户端")])]),v._v(" "),_("h2",{attrs:{id:"十四、http3-0-quic"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#十四、http3-0-quic"}},[v._v("#")]),v._v(" 十四、HTTP3.0/QUIC")]),v._v(" "),_("p",[v._v("TCP在丢包的时候会进行重传，前面有一个包没收到，就只能把后面的包放到缓冲区，应用层无法取数据。为了解决这个问题，Google又发明了"),_("code",[v._v("QUIC协议")]),v._v("。2018年改名为HTTP3.0")]),v._v(" "),_("ul",[_("li",[v._v("在传输层，使用UDP替代TCP")]),v._v(" "),_("li",[v._v("实现了一套新的拥塞控制算法，彻底解决了TCP中的队头阻塞问题")]),v._v(" "),_("li",[v._v("UDP不提供可靠的传输，但QUIC在UDP的基础上增加了一层来保证数据可靠性传输")])])])}),[],!1,null,null,null);_.default=r.exports}}]);