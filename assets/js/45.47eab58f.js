(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{323:function(t,a,s){"use strict";s.r(a);var p=s(10),n=Object(p.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_8-01-背包理论基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-01-背包理论基础"}},[t._v("#")]),t._v(" 8.01 背包理论基础")]),t._v(" "),a("p",[t._v("一维 dp 数组遍历顺序")]),t._v(" "),a("h2",{attrs:{id:"题目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[t._v("#")]),t._v(" 题目")]),t._v(" "),a("p",[t._v("背包最大重量为 4。")]),t._v(" "),a("p",[t._v("物品为：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th",[t._v("重量")]),t._v(" "),a("th",[t._v("价值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("物品 0")]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td",[t._v("15")])]),t._v(" "),a("tr",[a("td",[t._v("物品 1")]),t._v(" "),a("td",[t._v("3")]),t._v(" "),a("td",[t._v("20")])]),t._v(" "),a("tr",[a("td",[t._v("物品 2")]),t._v(" "),a("td",[t._v("4")]),t._v(" "),a("td",[t._v("30")])])])]),t._v(" "),a("p",[t._v("问背包能背的物品最大价值是多少")]),t._v(" "),a("h2",{attrs:{id:"一维-dp-数组-滚动数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一维-dp-数组-滚动数组"}},[t._v("#")]),t._v(" 一维 dp 数组（滚动数组）")]),t._v(" "),a("p",[t._v("对于背包问题其实状态都是可以压缩的。")]),t._v(" "),a("p",[t._v("在使用二维数组的时候，递推公式：dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);")]),t._v(" "),a("p",[a("strong",[t._v("其实可以发现如果把 dp[i - 1]那一层拷贝到 dp[i]上，表达式完全可以是：dp[i][j] = Math.max(dp")])]),t._v(" "),a("p",[a("strong",[t._v("[i][j], dp[i][j - weight[i]] + value[i]);")])]),t._v(" "),a("p",[a("strong",[t._v("与其把 dp[i - 1]这一层拷贝到 dp[i]上，不如只用一个一维数组了")]),t._v("，只用 dp[j]（一维数组，也可以理解是一个滚动数组）。")]),t._v(" "),a("p",[t._v("这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。")]),t._v(" "),a("p",[t._v("读到这里估计大家都忘了 dp[i][j]里的 i 和 j 表达的是什么了，i 是物品，j 是背包容量。")]),t._v(" "),a("p",[a("strong",[t._v("dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为 j 的背包，价值总和最大是多少")]),t._v("。")]),t._v(" "),a("p",[t._v("一定要时刻记住这里 i 和 j 的含义，要不然很容易看懵了。")]),t._v(" "),a("p",[t._v("动规五部曲分析如下：")]),t._v(" "),a("h3",{attrs:{id:"_1-确定-dp-数组的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-确定-dp-数组的定义"}},[t._v("#")]),t._v(" 1.确定 dp 数组的定义")]),t._v(" "),a("p",[t._v("在一维 dp 数组中，dp[j]表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]。")]),t._v(" "),a("h3",{attrs:{id:"_2-一维-dp-数组的递推公式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-一维-dp-数组的递推公式"}},[t._v("#")]),t._v(" 2.一维 dp 数组的递推公式")]),t._v(" "),a("p",[t._v("dp[j]为 容量为 j 的背包所背的最大价值，那么如何推导 dp[j]呢？")]),t._v(" "),a("p",[t._v("dp[j]可以通过 dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为 j - weight[i]的背包所背的最大价值。")]),t._v(" "),a("p",[t._v("dp[j - weight[i]] + value[i] 表示 容量为 j - 物品 i 重量 的背包 加上 物品 i 的价值。（也就是容量为 j 的背包，放入物品 i 了之后的价值即：dp[j]）")]),t._v(" "),a("p",[t._v("此时 dp[j]有两个选择，一个是取自己 dp[j] 相当于 二维 dp 数组中的 dp[i-1][j]，即不放物品 i，一个是取 dp[j - weight[i]] + value[i]，即放物品 i，指定是取最大的，毕竟是求最大价值，")]),t._v(" "),a("p",[t._v("所以递归公式为：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" weight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("可以看出相对于二维 dp 数组的写法，就是把 dp[i][j]中 i 的维度去掉了。")]),t._v(" "),a("h3",{attrs:{id:"_3-一维-dp-数组如何初始化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-一维-dp-数组如何初始化"}},[t._v("#")]),t._v(" 3.一维 dp 数组如何初始化")]),t._v(" "),a("p",[a("strong",[t._v("关于初始化，一定要和 dp 数组的定义吻合，否则到递推公式的时候就会越来越乱")]),t._v("。")]),t._v(" "),a("p",[t._v("dp[j]表示：容量为 j 的背包，所背的物品价值可以最大为 dp[j]，那么 dp[0]就应该是 0，因为背包容量为 0 所背的物品的最大价值就是 0。")]),t._v(" "),a("p",[t._v("那么 dp 数组除了下标 0 的位置，初始为 0，其他下标应该初始化多少呢？")]),t._v(" "),a("p",[t._v("看一下递归公式：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);")]),t._v(" "),a("p",[t._v("dp 数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非 0 下标都初始化为 0 就可以了。")]),t._v(" "),a("p",[a("strong",[t._v("这样才能让 dp 数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了")]),t._v("。")]),t._v(" "),a("p",[t._v("那么我假设物品价值都是大于 0 的，所以 dp 数组初始化的时候，都初始为 0 就可以了。")]),t._v(" "),a("h3",{attrs:{id:"_4-一维-dp-数组遍历顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-一维-dp-数组遍历顺序"}},[t._v("#")]),t._v(" 4.一维 dp 数组遍历顺序")]),t._v(" "),a("p",[t._v("代码如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" weight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 遍历物品")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("int j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bagWeight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" weight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 遍历背包容量")]),t._v("\n        dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" weight"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("二维 dp 遍历的时候，背包容量是从小到大，而一维 dp 遍历的时候，背包是从大到小。")]),t._v(" "),a("p",[a("strong",[t._v("倒序遍历是为了保证物品 i 只被放入一次！")]),t._v("。但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！")]),t._v(" "),a("p",[t._v("举一个例子：物品 0 的重量 weight[0] = 1，价值 value[0] = 15")]),t._v(" "),a("p",[t._v("如果正序遍历")]),t._v(" "),a("p",[t._v("dp[1] = dp[1 - weight[0]] + value[0] = 15")]),t._v(" "),a("p",[t._v("dp[2] = dp[2 - weight[0]] + value[0] = 30")]),t._v(" "),a("p",[t._v("此时 dp[2]就已经是 30 了，意味着物品 0，被放入了两次，所以不能正序遍历。")]),t._v(" "),a("p",[t._v("为什么倒序遍历，就可以保证物品只放入一次呢？")]),t._v(" "),a("p",[t._v("倒序就是先算 dp[2]")]),t._v(" "),a("p",[t._v("dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp 数组已经都初始化为 0）")]),t._v(" "),a("p",[t._v("dp[1] = dp[1 - weight[0]] + value[0] = 15")]),t._v(" "),a("p",[t._v("所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。")]),t._v(" "),a("p",[a("strong",[t._v("那么问题又来了，为什么二维 dp 数组历的时候不用倒序呢？")])]),t._v(" "),a("p",[t._v("因为对于二维 dp，dp[i][j]都是通过上一层即 dp[i - 1][j]计算而来，本层的 dp[i][j]并不会被覆盖！")]),t._v(" "),a("p",[a("strong",[t._v("再来看看两个嵌套 for 循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？")])]),t._v(" "),a("p",[t._v("不可以！")]),t._v(" "),a("p",[t._v("因为一维 dp 的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个 dp[j]就只会放入一个物品，即：背包里只放入了一个物品。")]),t._v(" "),a("p",[t._v("倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。")])])}),[],!1,null,null,null);a.default=n.exports}}]);