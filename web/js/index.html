<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 知识归纳 | 小草屋</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="藏点书">
    
    <link rel="preload" href="/blog/assets/css/0.styles.570f249f.css" as="style"><link rel="preload" href="/blog/assets/js/app.fc3b1f7d.js" as="script"><link rel="preload" href="/blog/assets/js/2.10e67aca.js" as="script"><link rel="preload" href="/blog/assets/js/102.26d5cba7.js" as="script"><link rel="preload" href="/blog/assets/js/3.03b63f54.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.9333a629.js"><link rel="prefetch" href="/blog/assets/js/100.1717e2f6.js"><link rel="prefetch" href="/blog/assets/js/101.440badd1.js"><link rel="prefetch" href="/blog/assets/js/103.a5fdcb38.js"><link rel="prefetch" href="/blog/assets/js/104.90433834.js"><link rel="prefetch" href="/blog/assets/js/105.2ad3bd2e.js"><link rel="prefetch" href="/blog/assets/js/106.3f989862.js"><link rel="prefetch" href="/blog/assets/js/107.46ef2997.js"><link rel="prefetch" href="/blog/assets/js/108.ea13c8c9.js"><link rel="prefetch" href="/blog/assets/js/109.da44c983.js"><link rel="prefetch" href="/blog/assets/js/11.356a4ee9.js"><link rel="prefetch" href="/blog/assets/js/110.f1c8cc47.js"><link rel="prefetch" href="/blog/assets/js/111.5d4d04ca.js"><link rel="prefetch" href="/blog/assets/js/112.199f405d.js"><link rel="prefetch" href="/blog/assets/js/113.51cad6b6.js"><link rel="prefetch" href="/blog/assets/js/114.8088b1c2.js"><link rel="prefetch" href="/blog/assets/js/115.9b057309.js"><link rel="prefetch" href="/blog/assets/js/116.776ecaa9.js"><link rel="prefetch" href="/blog/assets/js/12.813a8809.js"><link rel="prefetch" href="/blog/assets/js/13.a83d669b.js"><link rel="prefetch" href="/blog/assets/js/14.edb6e688.js"><link rel="prefetch" href="/blog/assets/js/15.eed9fa33.js"><link rel="prefetch" href="/blog/assets/js/16.d6cac6a3.js"><link rel="prefetch" href="/blog/assets/js/17.a883636d.js"><link rel="prefetch" href="/blog/assets/js/18.9e49f0e9.js"><link rel="prefetch" href="/blog/assets/js/19.fb2dbbac.js"><link rel="prefetch" href="/blog/assets/js/20.c2bff3b8.js"><link rel="prefetch" href="/blog/assets/js/21.209245d3.js"><link rel="prefetch" href="/blog/assets/js/22.5b759b23.js"><link rel="prefetch" href="/blog/assets/js/23.159c0568.js"><link rel="prefetch" href="/blog/assets/js/24.691eda93.js"><link rel="prefetch" href="/blog/assets/js/25.ed14c503.js"><link rel="prefetch" href="/blog/assets/js/26.2f5bfd04.js"><link rel="prefetch" href="/blog/assets/js/27.0295ebb3.js"><link rel="prefetch" href="/blog/assets/js/28.564a1359.js"><link rel="prefetch" href="/blog/assets/js/29.67ad2758.js"><link rel="prefetch" href="/blog/assets/js/30.aec49261.js"><link rel="prefetch" href="/blog/assets/js/31.9916019e.js"><link rel="prefetch" href="/blog/assets/js/32.ba65a4b9.js"><link rel="prefetch" href="/blog/assets/js/33.a1c09c3f.js"><link rel="prefetch" href="/blog/assets/js/34.d7b6a8f4.js"><link rel="prefetch" href="/blog/assets/js/35.73b2a46e.js"><link rel="prefetch" href="/blog/assets/js/36.bf38c325.js"><link rel="prefetch" href="/blog/assets/js/37.4a60b2bf.js"><link rel="prefetch" href="/blog/assets/js/38.0b65e2eb.js"><link rel="prefetch" href="/blog/assets/js/39.801d0e3e.js"><link rel="prefetch" href="/blog/assets/js/4.934917f7.js"><link rel="prefetch" href="/blog/assets/js/40.ba4281ef.js"><link rel="prefetch" href="/blog/assets/js/41.d62c69eb.js"><link rel="prefetch" href="/blog/assets/js/42.6025345d.js"><link rel="prefetch" href="/blog/assets/js/43.fa40ccea.js"><link rel="prefetch" href="/blog/assets/js/44.ffd4044a.js"><link rel="prefetch" href="/blog/assets/js/45.db668c12.js"><link rel="prefetch" href="/blog/assets/js/46.e141393c.js"><link rel="prefetch" href="/blog/assets/js/47.654c9f09.js"><link rel="prefetch" href="/blog/assets/js/48.cf75e45d.js"><link rel="prefetch" href="/blog/assets/js/49.a14bebe0.js"><link rel="prefetch" href="/blog/assets/js/5.e33501ae.js"><link rel="prefetch" href="/blog/assets/js/50.c3c565dc.js"><link rel="prefetch" href="/blog/assets/js/51.59972801.js"><link rel="prefetch" href="/blog/assets/js/52.e11f1e35.js"><link rel="prefetch" href="/blog/assets/js/53.953298e3.js"><link rel="prefetch" href="/blog/assets/js/54.c87c5f87.js"><link rel="prefetch" href="/blog/assets/js/55.eba4ab89.js"><link rel="prefetch" href="/blog/assets/js/56.c9c56347.js"><link rel="prefetch" href="/blog/assets/js/57.793e457a.js"><link rel="prefetch" href="/blog/assets/js/58.c2101aa3.js"><link rel="prefetch" href="/blog/assets/js/59.de19dd48.js"><link rel="prefetch" href="/blog/assets/js/6.f78f4531.js"><link rel="prefetch" href="/blog/assets/js/60.150c0435.js"><link rel="prefetch" href="/blog/assets/js/61.14efb9de.js"><link rel="prefetch" href="/blog/assets/js/62.f5a08a2d.js"><link rel="prefetch" href="/blog/assets/js/63.8d08033a.js"><link rel="prefetch" href="/blog/assets/js/64.7c1cc66b.js"><link rel="prefetch" href="/blog/assets/js/65.0a2453e3.js"><link rel="prefetch" href="/blog/assets/js/66.d74f0f9a.js"><link rel="prefetch" href="/blog/assets/js/67.8c5a610e.js"><link rel="prefetch" href="/blog/assets/js/68.d1d6dae6.js"><link rel="prefetch" href="/blog/assets/js/69.7fedf8eb.js"><link rel="prefetch" href="/blog/assets/js/7.01e9a040.js"><link rel="prefetch" href="/blog/assets/js/70.7dafa254.js"><link rel="prefetch" href="/blog/assets/js/71.d242e584.js"><link rel="prefetch" href="/blog/assets/js/72.70f543df.js"><link rel="prefetch" href="/blog/assets/js/73.b0df8875.js"><link rel="prefetch" href="/blog/assets/js/74.c079d86f.js"><link rel="prefetch" href="/blog/assets/js/75.c5e63c6b.js"><link rel="prefetch" href="/blog/assets/js/76.03815dd7.js"><link rel="prefetch" href="/blog/assets/js/77.f5f90b5d.js"><link rel="prefetch" href="/blog/assets/js/78.3cd1961a.js"><link rel="prefetch" href="/blog/assets/js/79.e045e315.js"><link rel="prefetch" href="/blog/assets/js/8.ddbfe6c6.js"><link rel="prefetch" href="/blog/assets/js/80.6114bdd6.js"><link rel="prefetch" href="/blog/assets/js/81.1770af99.js"><link rel="prefetch" href="/blog/assets/js/82.3b203e27.js"><link rel="prefetch" href="/blog/assets/js/83.cfe60cbb.js"><link rel="prefetch" href="/blog/assets/js/84.bd5308d8.js"><link rel="prefetch" href="/blog/assets/js/85.22752d2d.js"><link rel="prefetch" href="/blog/assets/js/86.1a9e6ffa.js"><link rel="prefetch" href="/blog/assets/js/87.838bb8c6.js"><link rel="prefetch" href="/blog/assets/js/88.7fef8a8f.js"><link rel="prefetch" href="/blog/assets/js/89.39788c3b.js"><link rel="prefetch" href="/blog/assets/js/9.64e9b99c.js"><link rel="prefetch" href="/blog/assets/js/90.356c5321.js"><link rel="prefetch" href="/blog/assets/js/91.0c268b47.js"><link rel="prefetch" href="/blog/assets/js/92.aa742cc4.js"><link rel="prefetch" href="/blog/assets/js/93.5672611b.js"><link rel="prefetch" href="/blog/assets/js/94.cdd7e4e5.js"><link rel="prefetch" href="/blog/assets/js/95.84bc5f4d.js"><link rel="prefetch" href="/blog/assets/js/96.ef20120e.js"><link rel="prefetch" href="/blog/assets/js/97.a31d2e01.js"><link rel="prefetch" href="/blog/assets/js/98.f720388b.js"><link rel="prefetch" href="/blog/assets/js/99.124adfe2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.570f249f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">小草屋</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/web/html/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/arithmetic/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/miscellany/" class="nav-link">
  杂项
</a></div><div class="nav-item"><a href="/blog/workingDiary/" class="nav-link">
  工作日记
</a></div><div class="nav-item"><a href="/blog/electron/" class="nav-link">
  electron
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/web/html/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/arithmetic/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/miscellany/" class="nav-link">
  杂项
</a></div><div class="nav-item"><a href="/blog/workingDiary/" class="nav-link">
  工作日记
</a></div><div class="nav-item"><a href="/blog/electron/" class="nav-link">
  electron
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/web/html/" class="sidebar-link">HTML 知识归纳</a></li><li><a href="/blog/web/css/" class="sidebar-link">CSS 知识归纳</a></li><li><a href="/blog/web/js/" aria-current="page" class="active sidebar-link">js 知识归纳</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#一、堆和栈的区别" class="sidebar-link">一、堆和栈的区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二、浅拷贝和深拷贝" class="sidebar-link">二、浅拷贝和深拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三、数组的方法" class="sidebar-link">三、数组的方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#改变原数组的方法" class="sidebar-link">改变原数组的方法</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#不改变原数组的方法" class="sidebar-link">不改变原数组的方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#四、数据类型的检查方案" class="sidebar-link">四、数据类型的检查方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#object-prototype-tostring-call" class="sidebar-link">Object.prototype.toString.call()</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#五、字符串的方法" class="sidebar-link">五、字符串的方法</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#六、for-in-和-for-for-的区别" class="sidebar-link">六、forin 和 forfor 的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#for-in" class="sidebar-link">for in</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#for-of" class="sidebar-link">for of</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#七、indexof、find、findindex-的区别" class="sidebar-link">七、indexOf、find、findIndex 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#八、js-继承" class="sidebar-link">八、JS 继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#_1-原型链继承" class="sidebar-link">1.原型链继承</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#_2-构造函数继承" class="sidebar-link">2.构造函数继承</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#_3-组合继承" class="sidebar-link">3.组合继承</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#_4-原型式继承" class="sidebar-link">4.原型式继承</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#_5-寄生式组合继承" class="sidebar-link">5.寄生式组合继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#九、js-垃圾回收机制" class="sidebar-link">九、JS 垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十、js-异步解决方案" class="sidebar-link">十、JS 异步解决方案</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十一、map-和-set" class="sidebar-link">十一、Map 和 Set</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#map" class="sidebar-link">Map</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#weakmap" class="sidebar-link">WeakMap</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#weakset" class="sidebar-link">WeakSet</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#map-和-object-的区别" class="sidebar-link">Map 和 Object 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十二、object-freeze-和-object-seal-方法" class="sidebar-link">十二、Object.freeze 和 Object.seal 方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#object-seal" class="sidebar-link">Object.seal()</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#object-freeze" class="sidebar-link">Object.freeze()</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十三、prototype-和proto区别" class="sidebar-link">十三、prototype 和proto区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十四、settimeout-和-setinterval-的区别" class="sidebar-link">十四、setTimeout 和 setInterval 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十五、闭包" class="sidebar-link">十五、闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#闭包的特性" class="sidebar-link">闭包的特性</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#优缺点" class="sidebar-link">优缺点</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#运用场景" class="sidebar-link">运用场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十六、作用域链" class="sidebar-link">十六、作用域链</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十七、原型和原型链" class="sidebar-link">十七、原型和原型链</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十八、事件代理" class="sidebar-link">十八、事件代理</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#十九、this" class="sidebar-link">十九、this</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十、事件模型" class="sidebar-link">二十、事件模型</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十一、new操作符" class="sidebar-link">二十一、new操作符</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十二、解决跨域" class="sidebar-link">二十二、解决跨域</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十三、模块化开发" class="sidebar-link">二十三、模块化开发</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十四、异步加载js" class="sidebar-link">二十四、异步加载js</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十五、内存泄漏操作" class="sidebar-link">二十五、内存泄漏操作</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十六、xml和json的区别" class="sidebar-link">二十六、XML和JSON的区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十七、web安全及防护原理" class="sidebar-link">二十七、web安全及防护原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#_1-跨站脚本攻击-xss" class="sidebar-link">1.跨站脚本攻击（XSS）</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#_2-跨站请求伪造-csrf" class="sidebar-link">2.跨站请求伪造（CSRF）</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十八、设计模式" class="sidebar-link">二十八、设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/#观察者模式和发布订阅模式" class="sidebar-link">观察者模式和发布订阅模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/web/js/#二十九、定义对象的方法" class="sidebar-link">二十九、定义对象的方法</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十、jquery源码的优点" class="sidebar-link">三十、jQuery源码的优点</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十一、javascript的数据类型" class="sidebar-link">三十一、JavaScript的数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十二、eval" class="sidebar-link">三十二、eval</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十三、-use-strict" class="sidebar-link">三十三、“use strict”</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十四、attribute和property" class="sidebar-link">三十四、attribute和property</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十五、es6" class="sidebar-link">三十五、ES6</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十六、面向对象编程" class="sidebar-link">三十六、面向对象编程</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十七、js判断数组" class="sidebar-link">三十七、JS判断数组</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十八、map和foreach" class="sidebar-link">三十八、map和forEach</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#三十九、函数式编程" class="sidebar-link">三十九、函数式编程</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#四十、箭头函数和普通函数" class="sidebar-link">四十、箭头函数和普通函数</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/#四十一、阻止冒泡和默认事件" class="sidebar-link">四十一、阻止冒泡和默认事件</a></li></ul></li><li><a href="/blog/web/writeJs/" class="sidebar-link">js 手写</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-知识归纳"><a href="#js-知识归纳" class="header-anchor">#</a> js 知识归纳</h1> <h2 id="一、堆和栈的区别"><a href="#一、堆和栈的区别" class="header-anchor">#</a> 一、堆和栈的区别</h2> <ul><li>栈内存主要用于存储基本类型的值和引用类型值的地址</li> <li>堆内存用于保存引用类型的值，可以通过栈内存的引用类型值的地址来获取</li></ul> <h2 id="二、浅拷贝和深拷贝"><a href="#二、浅拷贝和深拷贝" class="header-anchor">#</a> 二、浅拷贝和深拷贝</h2> <ul><li>浅拷贝可以简单的理解为，发生在栈中的拷贝行为，只能拷贝基本值和引用值的地址</li> <li>深拷贝可以简单的理解为，同时发生在栈和堆中的拷贝行为，除了拷贝基本值，地址中的对象也会发生拷贝</li></ul> <h2 id="三、数组的方法"><a href="#三、数组的方法" class="header-anchor">#</a> 三、数组的方法</h2> <h3 id="改变原数组的方法"><a href="#改变原数组的方法" class="header-anchor">#</a> 改变原数组的方法</h3> <ol><li>shift:将一个元素删除并且返回删除元素，删除第一项</li> <li>unshift:在原数组的最前端依次添加，并且返回新数组的长度</li> <li>push：在原数组的最后依次添加项，并返回新数组的长度</li> <li>pop：将一个元素移除并返回移除的项，最后一项</li> <li>reverse：反转数组的顺序</li> <li>sort：对数组进行依次排序</li> <li>splice：三个参数。第一个代表开始的下标，第二个代表 要删除的个数，第三个代表要替换的东西，返回被删除的数组</li></ol> <h3 id="不改变原数组的方法"><a href="#不改变原数组的方法" class="header-anchor">#</a> 不改变原数组的方法</h3> <ol><li>concat:拼接，连接多个数组</li> <li>slice:提取，返回被提取的字符</li> <li>join：将数组中所有元素以参数作为分隔符放入一个字符</li> <li>map,filter,some,every 等不改变原数组</li></ol> <h2 id="四、数据类型的检查方案"><a href="#四、数据类型的检查方案" class="header-anchor">#</a> 四、数据类型的检查方案</h2> <h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h3> <ul><li>优点：快速区分基本数据类型</li> <li>缺点：不能区分 Object、Array 和 Null，都返回 object</li></ul> <h3 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h3> <ul><li>优点：能够区分 Array、Object 和 Function，适合用于判断自定义的类实例对象</li> <li>缺点：Number，Boolean，String 基本数据类型不能判断</li></ul> <h3 id="object-prototype-tostring-call"><a href="#object-prototype-tostring-call" class="header-anchor">#</a> Object.prototype.toString.call()</h3> <ul><li>优点：精准判断数据类型</li></ul> <h2 id="五、字符串的方法"><a href="#五、字符串的方法" class="header-anchor">#</a> 五、字符串的方法</h2> <ul><li>charAt():返回指定索引位置的字符</li> <li>charCodeAt():返回指定索引位置字符的 Unicode 值</li> <li>concat():连接两个或多个字符串，返回连接后的字符串</li> <li>fromCharCode():将 Unicode 转换为字符串</li> <li>indexOf():返回字符串中检索指定字符第一次出现的位置</li> <li>lastIndexOf():返回字符串中检索指定字符最后一次出现的位置</li> <li>localeCompare():用本地特定的顺序来比较两个字符串</li> <li>match():找到一个或多个正则表达式的匹配</li> <li>replace():替换与正则表达式匹配的子串</li> <li>search():检索与正则表达式相匹配的值</li> <li>slice():提取字符串的片断，并在新的字符串中返回被提取的部分</li> <li>split():把字符串分割为子字符串数组</li> <li>substr():从起始索引号提取字符串中指定数目的字符</li> <li>substring():提取字符串中两个指定的索引号之间的字符</li> <li>toLocaleLowerCase():根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射</li> <li>toLocaleUpperCase():根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射</li> <li>toLowerCase():把字符串转换为小写</li> <li>toUpperCase():把字符串转换为大写</li> <li>toString():返回字符串对象值</li> <li>trim():移除字符串首尾空白</li> <li>valueOf():返回某个字符串对象的原始值</li></ul> <h2 id="六、for-in-和-for-for-的区别"><a href="#六、for-in-和-for-for-的区别" class="header-anchor">#</a> 六、for_in 和 for_for 的区别</h2> <h3 id="for-in"><a href="#for-in" class="header-anchor">#</a> for in</h3> <ul><li>获取对象的键名</li> <li>ES5 语法标准</li> <li>可遍历普通对象</li> <li>可遍历到原型链上的属性</li></ul> <h3 id="for-of"><a href="#for-of" class="header-anchor">#</a> for of</h3> <ul><li>获取对象的键值</li> <li>ES6 语法标准</li> <li>不能遍历普通对象，普通对象是不可迭代的</li></ul> <h2 id="七、indexof、find、findindex-的区别"><a href="#七、indexof、find、findindex-的区别" class="header-anchor">#</a> 七、indexOf、find、findIndex 的区别</h2> <ul><li>indexOf:用于输入一个值进行查找，找到了返回值的索引，没找到返回-1</li> <li>find:输入一个函数，找到第一个满足条件的值并返回，没有找到返回 undefined</li> <li>findIndexOf：输入一个函数，找到第一个满足条件的值并返回值的索引，没有找到返回-1</li></ul> <h2 id="八、js-继承"><a href="#八、js-继承" class="header-anchor">#</a> 八、JS 继承</h2> <h3 id="_1-原型链继承"><a href="#_1-原型链继承" class="header-anchor">#</a> 1.原型链继承</h3> <p>将父类的实例作为子类的原型</p> <ul><li><p>优点：父类的方法 可以复用</p></li> <li><p>缺点：</p> <ol><li>父类的所以引用类型，会被所有的子类共享，只要修改其中一个，其他子类也会受到影响</li> <li>子类实例不能向父类构造函数传参</li></ol></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;lisi&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-构造函数继承"><a href="#_2-构造函数继承" class="header-anchor">#</a> 2.构造函数继承</h3> <p>在子类的构造函数中调用父类，使用 call、apply 方法改变 this</p> <ul><li>优点：
<ol><li>父类的引用属性不会被共享</li> <li>子类实例可以向父类构造函数传参</li></ol></li> <li>缺点:子类不能访问父类原型上的方法和属性</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>info <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> name<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">&quot;bobi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;bobi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> child2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;anna&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-组合继承"><a href="#_3-组合继承" class="header-anchor">#</a> 3.组合继承</h3> <p>结合了原型链继承和构造函数继承，通过将父类的实例作为子类的原型来获取父类原型上的属性和方法，通过构造函数来获取实例属性</p> <ul><li>优点:
<ol><li>父类的引用属性不会被共享</li> <li>子类的实例可以向父类的构造函数传参</li> <li>子类可以访问父类原型上的方法和属性</li></ol></li> <li>缺点:子类的原型上会多出不需要的父类的方法和属性</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getNmae</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_4-原型式继承"><a href="#_4-原型式继承" class="header-anchor">#</a> 4.原型式继承</h3> <p>对参数对象的一种浅复制</p> <ul><li>优点:父类的方法可以共用</li> <li>缺点:
<ol><li>子类实例不能向父类传参</li> <li>父类的引用属性会被共享</li></ol></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-寄生式组合继承"><a href="#_5-寄生式组合继承" class="header-anchor">#</a> 5.寄生式组合继承</h3> <ol><li>在子类的构造函数中调用父类的构造函数</li> <li>将子类的原型设置为父类的原型</li> <li>将原型上的 constructor 设置为子类</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">Child<span class="token punctuation">,</span> Parent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token function">objectCopy</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>
  <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;rose&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;lily&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;tom&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">&quot;anna&quot;</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="九、js-垃圾回收机制"><a href="#九、js-垃圾回收机制" class="header-anchor">#</a> 九、JS 垃圾回收机制</h2> <p>垃圾回收机制：浏览器的 javascript 具有自动的垃圾回收机制，垃圾收集器会定期的找出那些不被继续使用的变量，然后释放其内存</p> <ul><li>标记清除法：当变量进入执行环境时，被标记为&quot;进入环境&quot;，当变量离开执行环境时，被标记为&quot;离开环境&quot;，那么垃圾回收器就会销毁这些离开环境的变量并回收内存</li> <li>计数引用法：内存被引用一次，计数加 1 次，移除引用就减 1，减到 0 时，浏览器就回收它</li></ul> <h2 id="十、js-异步解决方案"><a href="#十、js-异步解决方案" class="header-anchor">#</a> 十、JS 异步解决方案</h2> <ol><li>回调函数
<ul><li>优点：解决了同步问题</li> <li>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</li></ul></li> <li>Promise
<ul><li>优点：解决了回调地狱</li> <li>缺点：无法取消 Promsie，错误需要通过回调函数捕获</li></ul></li> <li>Generator
<ul><li>优点：可以控制函数的执行</li></ul></li> <li>Async/await
<ul><li>优点：代码清晰，不用像 Promsie 一样写一堆的 then，解决了回调地狱</li> <li>缺点：异步代码改为同步代码，对于没有依赖性的多个异步操作就会导致性能降低</li></ul></li></ol> <h2 id="十一、map-和-set"><a href="#十一、map-和-set" class="header-anchor">#</a> 十一、Map 和 Set</h2> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>是一组键值对的结构，key 不仅可以是字符串也可以是引用类型</p> <ol><li>属性：size</li> <li>方法：has、set、get、delete、clear</li> <li>遍历方法：keys、values、entries、forEach</li></ol> <h3 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h3> <p>也是一组键值对的结构，key 必须是引用类型，弱引用</p> <ol><li>没有 size 属性</li> <li>方法：has、set、get、delete</li> <li>不可迭代</li></ol> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p>对象类似于数组，成员的值都是唯一的</p> <ol><li>属性：size</li> <li>方法：has、add、delete、clear</li> <li>遍历方法：keys、values、entries、forEach</li></ol> <h3 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h3> <p>成员是引用类型，具有唯一性，弱引用，垃圾回收机制不会考虑 set 内的引用</p> <ol><li>没有 size 属性</li> <li>方法：has、add、delete</li> <li>不可迭代</li></ol> <h3 id="map-和-object-的区别"><a href="#map-和-object-的区别" class="header-anchor">#</a> Map 和 Object 的区别</h3> <ol><li>在 Object 中，key 只能是 Symbol 和 String；而 Map 中 key 可以为任何值</li> <li>获取 Map 的长度可以通过 size 属性，而 Object 需要循环计算</li> <li>Map 是可迭代对象，而普通对象不可以迭代</li></ol> <h2 id="十二、object-freeze-和-object-seal-方法"><a href="#十二、object-freeze-和-object-seal-方法" class="header-anchor">#</a> 十二、Object.freeze 和 Object.seal 方法</h2> <h3 id="object-seal"><a href="#object-seal" class="header-anchor">#</a> Object.seal()</h3> <p>封闭某个对象</p> <ol><li>阻止添加新元素</li> <li>现有的属性不可配置</li> <li>属性值可被修改</li></ol> <h3 id="object-freeze"><a href="#object-freeze" class="header-anchor">#</a> Object.freeze()</h3> <p>冻结某个对象</p> <ol><li>阻止添加新元素</li> <li>现有的属性不可配置</li> <li>属性值不可被修改</li></ol> <h2 id="十三、prototype-和proto区别"><a href="#十三、prototype-和proto区别" class="header-anchor">#</a> 十三、prototype 和<strong>proto</strong>区别</h2> <ul><li>__proto__是每个对象都有的一个属性，可以用 Object.getPrototypeOf()代替__proto__</li> <li>prototype 是函数才会有的属性</li></ul> <h2 id="十四、settimeout-和-setinterval-的区别"><a href="#十四、settimeout-和-setinterval-的区别" class="header-anchor">#</a> 十四、setTimeout 和 setInterval 的区别</h2> <p>对于定时器，指定的时间间隔表示何时将定时器的代码添加到执行队列，而不是何时实际执行代码</p> <ul><li>setTimeout：单次执行</li> <li>setInterval：循环执行</li></ul> <p>使用 setInterval()创建定时器会有两个问题：</p> <ol><li>某些间隔会被跳过</li> <li>多个定时器的代码执行之间的间隔可能会比预期的小</li></ol> <h2 id="十五、闭包"><a href="#十五、闭包" class="header-anchor">#</a> 十五、闭包</h2> <p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用域链。</p> <h3 id="闭包的特性"><a href="#闭包的特性" class="header-anchor">#</a> 闭包的特性</h3> <ul><li>内部函数可以引用外层变量</li> <li>变量不会被垃圾回收机制回收</li></ul> <h3 id="优缺点"><a href="#优缺点" class="header-anchor">#</a> 优缺点</h3> <ul><li>好处：能实现封装和缓存</li> <li>坏处：消耗内存、不正当的使用会导致内存溢出的问题</li></ul> <h3 id="运用场景"><a href="#运用场景" class="header-anchor">#</a> 运用场景</h3> <ul><li>防抖</li> <li>节流</li></ul> <h2 id="十六、作用域链"><a href="#十六、作用域链" class="header-anchor">#</a> 十六、作用域链</h2> <ul><li>作用域链是一种用于查找变量和函数的机制，它是由当前执行环境和其所有父级执行环境的变量对象组成的链式结构。当在一个执行环境中访问变量或函数时，会首先在当前执行环境的变量对象中查找，如果找不到，则会沿着作用域链向上查找，直到找到对应变量或函数，或者到达最外层的全局对象。</li> <li>作用域链的创建是在函数定义时确定的，它与函数定义的位置有关。</li> <li>作用域就是变量与函数的可访问范围</li></ul> <h2 id="十七、原型和原型链"><a href="#十七、原型和原型链" class="header-anchor">#</a> 十七、原型和原型链</h2> <ul><li>每个对象都会在内存初始化一个<code>__proto__</code>属性，<code>__proto__</code>指向就是对象的原型</li> <li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去到<code>__proto__</code>指向的对象上查找，一层层的查找直到找到这个属性，或者找到<code>object</code>上的<code>null</code>，这样的一条链路就是原型链</li></ul> <h2 id="十八、事件代理"><a href="#十八、事件代理" class="header-anchor">#</a> 十八、事件代理</h2> <ul><li>将原本需要绑定的事件委托给父元素，让父元素担当事件监听职务。</li> <li>可以大量节省内存占用，减少事件注册</li> <li>原理就是DOM元素的事件冒泡</li></ul> <h2 id="十九、this"><a href="#十九、this" class="header-anchor">#</a> 十九、this</h2> <ul><li>在全局作用域中，<code>this</code>指向全局对象（window）</li> <li>在函数中
<ul><li>如果函数是作为对象的方法调用，<code>this</code>指向调用该方法的对象</li> <li>如果函数是作为普通函数调用，<code>this</code>指向全局对象（非严格模式）或<code>undefined</code>（严格模式）</li> <li>如果函数是通过<code>call</code>、<code>apply</code>或<code>bind</code>方法调用，<code>this</code>指向<code>call</code>、<code>apply</code>或<code>bind</code>方法的第一个参数</li> <li>如果函数是作为构造函数调用（使用<code>new</code>关键字），<code>this</code>指向新创建的对象</li></ul></li> <li>在箭头函数中，<code>this</code>指向继承自外部作用域，它不会因为调用方式的改变而改变</li></ul> <h2 id="二十、事件模型"><a href="#二十、事件模型" class="header-anchor">#</a> 二十、事件模型</h2> <p>事件流分为三个阶段：</p> <ol><li><strong>捕获阶段（Capture Phase）</strong>：事件从最外层的父节点开始向下传递，直到达到目标元素的父节点。在捕获阶段，事件会经过父节点、祖父节点等，但不会触发任何事件处理程序。</li> <li><strong>目标阶段（Target Phase）</strong>：事件到达目标元素本身，触发目标元素上的事件处理程序。如果事件有多个处理程序绑定在目标元素上，它们会按照添加的顺序依次执行。</li> <li><strong>冒泡阶段（Bubble Phase）</strong>：事件从目标元素开始向上冒泡，传递到父节点，直到传递到最外层的父节点或根节点。在冒泡阶段，事件会依次触发父节点、祖父节点等的事件处理程序。</li></ol> <h2 id="二十一、new操作符"><a href="#二十一、new操作符" class="header-anchor">#</a> 二十一、new操作符</h2> <ol><li>创建一个新的空对象</li> <li>将新对象的原型链接到构造函数的原型对象</li> <li>改变构造函数<code>this</code>指向到新对象</li> <li>执行构造函数，并传入参数</li> <li>如果构造函数没有显式返回一个对象，则返回新对象</li></ol> <h2 id="二十二、解决跨域"><a href="#二十二、解决跨域" class="header-anchor">#</a> 二十二、解决跨域</h2> <blockquote><p>同源策略：浏览器的安全策略，同源需要端口、域名和协议三者相同，只要有一个不同就会发生跨域</p></blockquote> <ol><li><p>通过jsonp跨域</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 生成唯一的回调函数名</span>
  <span class="token keyword">const</span> callbackName <span class="token operator">=</span> <span class="token string">'jsonp_'</span> <span class="token operator">+</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 将参数拼接到 URL 中</span>
  <span class="token keyword">const</span> queryString <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span> <span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 创建 script 元素</span>
  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url <span class="token operator">+</span> <span class="token string">'?'</span> <span class="token operator">+</span> queryString <span class="token operator">+</span> <span class="token string">'&amp;callback='</span> <span class="token operator">+</span> callbackName<span class="token punctuation">;</span>

  <span class="token comment">// 定义回调函数</span>
  window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用回调函数</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 删除 script 元素和回调函数</span>
    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 将 script 元素添加到页面中</span>
  document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><code>nginx</code>代理跨域</p></li> <li><p>nodejs中间件代理跨域</p> <ul><li>使用nodejs构建一个中间件，在服务器代理请求，将跨域请求转发到同源接口，然后将响应返回给前端</li></ul></li> <li><p>CORS（跨域资源共享）</p> <ul><li>在响应头部设置<code>Access-Control-Allow-Origin</code>，允许访问的域名</li></ul></li> <li><p><code>webSocket</code></p> <ul><li><code>webSocket</code>不受同源策略限制</li></ul></li></ol> <h2 id="二十三、模块化开发"><a href="#二十三、模块化开发" class="header-anchor">#</a> 二十三、模块化开发</h2> <ol><li><p>立即执行函数模式</p> <ul><li><p>使用立即执行函数创建模块，将私有成员放在函数作用域内，不直接暴漏给外部</p></li> <li><p>通过返回一个包含公共方法的对象，使这些方法可以在外部访问</p></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> privateVar <span class="token operator">=</span> <span class="token string">'Private Variable'</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">privateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is a private method'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">publicMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'This is a public method'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">publicMethod</span><span class="token operator">:</span> publicMethod
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token function">publicMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p><code>commonJS</code></p> <ul><li>使用<code>require</code>导入模块，使用<code>module.exports</code>或<code>exports</code>导出模块</li> <li>适合nodejs环境</li></ul></li> <li><p>ES Modules</p> <ul><li>使用<code>import</code>导入模块，使用<code>export</code>导出模块</li> <li>适用于现代浏览器环境和支持ES6模块的工具链</li></ul></li> <li><p>AMD</p> <ul><li>适用<code>define</code>定义模块，通过异步加载模块</li> <li>适用于浏览器环境和需要按需加载模块的场景</li></ul></li></ol> <h2 id="二十四、异步加载js"><a href="#二十四、异步加载js" class="header-anchor">#</a> 二十四、异步加载js</h2> <ol><li>设置<code>&lt;script&gt;</code>属性<code>async</code></li> <li>设置<code>&lt;script&gt;</code>属性<code>defer</code></li> <li>动态创建<code>script DOM</code></li> <li>异步加载库<code>LABjs</code></li></ol> <h2 id="二十五、内存泄漏操作"><a href="#二十五、内存泄漏操作" class="header-anchor">#</a> 二十五、内存泄漏操作</h2> <blockquote><p>javascript内存泄漏指对象在不需要使用它时仍存在，导致占用的内存不能使用或回收</p></blockquote> <ol><li>闭包函数</li> <li>循环引用</li> <li>控制台日志</li> <li>定时器</li></ol> <h2 id="二十六、xml和json的区别"><a href="#二十六、xml和json的区别" class="header-anchor">#</a> 二十六、XML和JSON的区别</h2> <p><code>XML</code>（可扩展标记语言）和<code>JSON</code>（javascript对象表示法）是两种常用的数据格式</p> <ol><li>数据体积方面
<ul><li><code>JSON</code>相对于<code>XML</code>来说，数据体积小，所以传输的速度更快</li></ul></li> <li>数据交互方面
<ul><li><code>JSON</code>与javascript的交互更加方便，因为<code>JSON</code>数据可以直接被js解析和处理，无需额外的转换步骤</li> <li><code>XML</code>需要使用DOM操作来解析和处理数据，相对而言更加复杂</li></ul></li> <li>数据描述方面
<ul><li><code>XML</code>对数据的描述性较强，它使用标签来标识数据的结构和含义，可以自定义标签名，使数据更具有可读性和可扩展性</li></ul></li></ol> <h2 id="二十七、web安全及防护原理"><a href="#二十七、web安全及防护原理" class="header-anchor">#</a> 二十七、web安全及防护原理</h2> <h3 id="_1-跨站脚本攻击-xss"><a href="#_1-跨站脚本攻击-xss" class="header-anchor">#</a> 1.跨站脚本攻击（XSS）</h3> <blockquote><p>指攻击者在WEB页面里插入恶意HTML标签或者javascript代码</p></blockquote> <ul><li>防护原理
<ul><li>对用户的输入进行合适的转义和过滤，转义符（\）进行转义</li> <li>CSP白名单设置</li></ul></li></ul> <h3 id="_2-跨站请求伪造-csrf"><a href="#_2-跨站请求伪造-csrf" class="header-anchor">#</a> 2.跨站请求伪造（CSRF）</h3> <blockquote><p>利用用户的登录态，发起恶意请求</p></blockquote> <ul><li>防护原理
<ul><li>请求时带上验证信息，比如token和验证码</li> <li>验证请求来源</li></ul></li></ul> <h2 id="二十八、设计模式"><a href="#二十八、设计模式" class="header-anchor">#</a> 二十八、设计模式</h2> <ol><li>工厂模式（Factory Pattern）
<ul><li>优点：封装了对象的创建过程，降低了耦合性，提高了灵活性和可扩展性</li> <li>缺点：增加了代码的复杂性，需要创建工厂类</li> <li>使用场景：当需要根据不同条件创建不同对象时，可以使用工厂模式</li></ul></li> <li>单例模式（Singleton Pattern）
<ul><li>优点：确保一个类只有一个实例，节省系统资源，提供全局访问点</li> <li>缺点：可能引入全局状态，并不利于扩展和测试</li> <li>适用场景：当需要全局唯一的对象实例时，例如日志记录器、全局配置对象等</li></ul></li> <li>观察者模式（Observer Pattern）
<ul><li>优点：实现了对象之间的松耦合，支持广播通信，当一个对象状态发生变化时，可以通知依赖它的其他对象进行更新</li> <li>缺点：可能导致性能问题和内存泄漏，需要合理的管理观察者列表</li> <li>适用场景：当需要实现对象之间的一对多关系，一个对象改变需要通知其他多个对象</li></ul></li> <li>发布订阅模式（Publish-Subscribe Pattern）
<ul><li>优点：解耦了发布者和订阅者，使它们可以独立变化，增加了代码的灵活性和可维护性</li> <li>缺点：可能会导致发布者过度发布消息，造成性能问题</li> <li>适用场景：当存在一对多的关系，一个对象的状态变化需要通知多个其他对象时，可以使用发布订阅模式。</li></ul></li></ol> <h3 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="header-anchor">#</a> 观察者模式和发布订阅模式</h3> <ol><li>相同之处：
<ul><li>都用于实现对象之间得消息通信和事件处理</li> <li>都支持解耦，让发布者和订阅者之间相互独立</li></ul></li> <li>区别：
<ul><li>关注点不同：观察者模式关注的是一个被观察者对象和多个观察者对象之间的关系。当被观察者对象的状态发生变化时，它会通知所有的观察者对象进行更新。而发布订阅模式关注的是发布者和订阅者之间的关系，发布者将消息发送到事件总线，然后由事件总线将消息发送给所有订阅者。</li> <li>中间间存在与否：发布订阅模式通常需要一个中间件来管理消息的发布和订阅，这样发布者和订阅者之间的通信通过中间件进行。而观察者模式则直接在被观察者对象和观察者对象之间进行通信，没有中间件参与。</li> <li>观察者模式中，被观察者对象和观察者对象之间是直接关联的，被观察者对象需要知道每个观察者对象的存在。而在发布订阅模式中，发布者和订阅者之间并不直接关联，它们只与中间件进行通信，发布者和订阅者之间的耦合更加松散。</li></ul></li></ol> <h2 id="二十九、定义对象的方法"><a href="#二十九、定义对象的方法" class="header-anchor">#</a> 二十九、定义对象的方法</h2> <ol><li>对象字面量：<code>let obj = {}</code></li> <li>构造函数：<code>let obj = new Object()</code></li> <li><code>Object.create()</code>：<code>let obj = Object.create(Object.prototype)</code></li></ol> <h2 id="三十、jquery源码的优点"><a href="#三十、jquery源码的优点" class="header-anchor">#</a> 三十、jQuery源码的优点</h2> <ol><li>结构清晰，模块化的设计使各个功能模块之间相互独立，易于维护和扩展</li> <li>采用了很多优化手段，例如缓存DOM查询结果、事件委托等，以提高性能和效率</li> <li>提供了一致而强大的选择器功能</li> <li>封装了跨浏览器的解决方案，解决了浏览器的兼容性问题</li> <li>提供了丰富的DOM操作方法和动画效果</li></ol> <h2 id="三十一、javascript的数据类型"><a href="#三十一、javascript的数据类型" class="header-anchor">#</a> 三十一、JavaScript的数据类型</h2> <ol><li>原始数据类型：
<ul><li><code>undefined</code>： 表示未定义的值</li> <li><code>Null</code>：表示空值</li> <li><code>Boolean</code>：表示布尔值，只有两个取值：<code>true</code>和<code>false</code></li> <li><code>Number</code>：表示数字，包括整数和浮点数</li> <li><code>String</code>：表示字符串</li> <li><code>Symbol</code>：表示唯一的、不可变的值</li></ul></li> <li>引用数据类型
<ul><li><code>Object</code>：表示对象，是一种复合值，可以包含多个键值对</li> <li><code>Array</code>：表示数组，是一种有序的、可变的集合</li> <li><code>Function</code>：表示函数，可以执行特定的任务</li> <li><code>Date</code>：表示日期和时间</li> <li><code>RegExp</code>：表示正则表达式，用于匹配和处理字符串</li> <li><code>Error</code>：表示错误对象，用于捕获和处理异常情况</li></ul></li></ol> <h2 id="三十二、eval"><a href="#三十二、eval" class="header-anchor">#</a> 三十二、eval</h2> <p><code>eval()</code>是javascript的一个全局函数，用于将传入的字符串作为javascript代码进行解析和执行</p> <ol><li>动态执行代码：<code>eval()</code>可以将字符串作为javascript代码进行执行，将字符串解析为可执行的javascript代码。这样可以动态生成和执行代码，灵活性较高。</li> <li>计算字符串表达式：<code>eval()</code>可以计算传入的字符串表达式并返回结果</li> <li>解析JSON：在某些情况下，可以适用<code>eval()</code>将JSON字符串解析为javascript对象。</li></ol> <h2 id="三十三、-use-strict"><a href="#三十三、-use-strict" class="header-anchor">#</a> 三十三、“use strict”</h2> <p>用于告诉javascript解析器在解析代码时采用严格模式</p> <p>好处：</p> <ol><li>消除了一些javascript代码的不安全操作，使代码更安全</li> <li>阻止使用一些不推荐或已废弃的语法和特性</li> <li>强制执行更严格的语法和错误检查，减少潜在的错误</li> <li>提高性能，某些优化操作只在严格默模式下生效</li></ol> <p>限制：</p> <ol><li>变量必须先声明再使用</li> <li>禁止使用<code>with</code>语句</li> <li>禁止this指向全局对象</li></ol> <h2 id="三十四、attribute和property"><a href="#三十四、attribute和property" class="header-anchor">#</a> 三十四、attribute和property</h2> <ul><li><code>attribute</code>是dom元素在文档中作为html标签拥有的属性</li> <li><code>property</code>是dom元素在js中作为对象拥有的属性</li> <li>对于<code>html</code>的标准元素来说，<code>attribute</code>和<code>property</code>同步的，会自动更新</li></ul> <h2 id="三十五、es6"><a href="#三十五、es6" class="header-anchor">#</a> 三十五、ES6</h2> <ol><li>块级作用域：引入了let和const关键字，允许在块级作用域中声明变量，解决了变量提升和作用域污染问题</li> <li>箭头函数：自动绑定了this</li> <li>模板字符串：实现更灵活的字符串拼接和格式化</li> <li>解构赋值：通过解构赋值语法，可以从数组和对象中提取值，并赋给对应的变量，简化了变量赋值的操作</li> <li>默认参数：函数可以定义默认参数</li> <li>扩展运算符：使用三个点（...）进行数组和对象的展开操作</li> <li>Promise：解决了回调地狱</li> <li>类：class关键字定义类</li> <li>模块化：import和export语法导入和导出模块</li></ol> <h2 id="三十六、面向对象编程"><a href="#三十六、面向对象编程" class="header-anchor">#</a> 三十六、面向对象编程</h2> <p>面向对象编程（Object-Oriented Programming，OOP）是一种编程思想和方法论，其基本思想是以对象为中心，通过封装、继承和多态等机制来组织和管理代码。</p> <p>优点：</p> <ul><li>易维护性：对象的封装性和模块化使代码易于维护和理解</li> <li>代码重用性：通过继承和组合等机制，可以重用已有的类和代码</li> <li>灵活性和可扩展性：面向对象编程提供了灵活的结构和抽象层次，使得代码易于扩展和修改，适应需求的变化。</li> <li>可靠性：封装和继承等机制可以提高代码的可靠性和可测试性，减少错误的发生和影响范围。</li> <li>可理解性：面向对象的代码通常具有良好的可读性和可理解性，对象和类的设计使得代码更加直观和自然。</li></ul> <h2 id="三十七、js判断数组"><a href="#三十七、js判断数组" class="header-anchor">#</a> 三十七、JS判断数组</h2> <ol><li><code>instanceof</code>：<code>arr instanceof Array</code></li> <li><code>constructor</code>：<code>arr.constructor === Array</code></li> <li><code>Object.prototype.toString.call()</code>：<code>Object.prototype.toString.call(arr) === '[object Array]'</code></li> <li><code>isArray()</code>：<code>isArray(arr)</code></li></ol> <h2 id="三十八、map和foreach"><a href="#三十八、map和foreach" class="header-anchor">#</a> 三十八、map和forEach</h2> <ul><li>map和forEach都是遍历数组的方法</li> <li>map方法会生成一个新数组，并将每次遍历的返回值顺序放入新数组中。而forEach方法没有返回值，仅用于遍历数组</li></ul> <h2 id="三十九、函数式编程"><a href="#三十九、函数式编程" class="header-anchor">#</a> 三十九、函数式编程</h2> <p>通过组合和应用函数来进行开发程序</p> <p>特点：</p> <ol><li>纯函数：函数的输出只由输入决定，不会产生副作用，对同样的输入始终返回相同的输出。</li> <li>不可变性：数据一旦创建就不能被修改，任何对数据的修改都会创建一个新的数据副本</li> <li>高阶函数：函数可以作为参数传递给其他函数，也可以作为返回值返回</li> <li>函数组合：通过将多个函数组合成一个新的函数，可以实现更复杂的逻辑</li> <li>惰性计算：只在需要的时候才进行计算，避免是不必要的计算</li></ol> <h2 id="四十、箭头函数和普通函数"><a href="#四十、箭头函数和普通函数" class="header-anchor">#</a> 四十、箭头函数和普通函数</h2> <ol><li>this指向：箭头函数没有自己的this， 它会捕获所在上下文的this值。普通函数的this是在运行时确定的，根据调用方式决定</li> <li>不可作为构造函数：箭头函数不能使用new关键字创建实例，它没有自己的<code>prototype</code>属性，无法进行实例化</li> <li>无<code>arguments</code>对象：箭头函数没有自己的<code>arguments</code>对象，可以使用<code>Rest</code>参数来代替</li></ol> <h2 id="四十一、阻止冒泡和默认事件"><a href="#四十一、阻止冒泡和默认事件" class="header-anchor">#</a> 四十一、阻止冒泡和默认事件</h2> <ul><li>阻止冒泡
<ul><li><code>event.stopPropagation()</code></li> <li><code>event.cancelBubble = true</code>，IE浏览器</li></ul></li> <li>默认事件
<ul><li><code>event.preventDefault()</code></li> <li><code>return false</code>，IE浏览器</li></ul></li></ul> <section class="content"><div><span data-flag-title="Your Article Title" class="leancloud-visitors"><em class="post-meta-item-text">阅读量：</em> <i class="leancloud-visitors-count"></i></span></div> <h3><a href="javascript:;"></a>
    评 论：
  </h3> <div id="vcomments"></div></section></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/27/2023, 7:19:13 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/web/css/" class="prev">
        CSS 知识归纳
      </a></span> <span class="next"><a href="/blog/web/writeJs/">
        js 手写
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.fc3b1f7d.js" defer></script><script src="/blog/assets/js/2.10e67aca.js" defer></script><script src="/blog/assets/js/102.26d5cba7.js" defer></script><script src="/blog/assets/js/3.03b63f54.js" defer></script>
  </body>
</html>
